## Всегда используйте target_session_attrs=read-write (или primary) при подключении к кластеру PostgreSQL

При работе с кластерами PostgreSQL, особенно в конфигурациях с высокой доступностью (High Availability, HA), 
разработчики часто сталкиваются с ошибками типа "cannot execute INSERT in a read-only transaction". Эти ошибки 
возникают, когда приложение пытается выполнить операцию записи на узел, который в данный момент является репликой 
(read-only). Особенно остро эта проблема проявляется в моменты переключения мастера: пул соединений вашего 
приложения может все еще содержать коннекты к бывшему мастеру, ставшему репликой, или же балансировщик может 
направить новый запрос на запись к реплике.

К счастью, драйверы PostgreSQL предоставляют элегантное решение этой проблемы – параметр строки подключения 
`target_session_attrs`. Этот параметр позволяет указать, какого типа сессию ожидает ваше приложение. Наиболее полезным 
значением для приложений, выполняющих операции чтения и записи, является `read-write`. В этой статье мы подробно разберем, 
почему это так важно, продемонстрируем проблему на практике и покажем, как `target_session_attrs=read-write` спасает ситуацию.
Использование `target_session_attrs=primary` будет описано в конце.

### Подготовка тестового окружения: кластер PostgreSQL в Яндекс.Облаке

Для наглядной демонстрации мы развернем отказоустойчивый кластер PostgreSQL в Яндекс.Облаке. Это позволит нам легко 
симулировать переключение мастера и наблюдать за поведением приложения. Для управления инфраструктурой мы будем 
использовать Terraform.

Ниже приведен код Terraform (`main.tf`), который описывает создание кластера PostgreSQL с тремя хостами в разных зонах 
доступности, а также необходимой сети, подсетей, пользователя и базы данных. Этот кластер будет сконфигурирован для 
высокой доступности.

```terraform
{{ cat "main.tf" }}
```

Этот Terraform-код создаст:
*   VPC (виртуальное частное облако) и три подсети в разных зонах доступности (`ru-central1-a`, `ru-central1-b`, `ru-central1-d`).
*   Кластер Managed Service for PostgreSQL с тремя хостами (один мастер и две реплики), распределенными по этим зонам. 
* Мы используем версию PostgreSQL 16 и небольшие ресурсы (`s2.micro`, 16 ГБ SSD) для демонстрационных целей.
*   Пользователя `test` с паролем и базу данных `testdb`.
*   Также, для удобства, будет сгенерирован файл `.env` со всеми необходимыми параметрами подключения к кластеру. 
* Обратите внимание, что в этом файле параметр `TARGET_SESSION_ATTRS` по умолчанию установлен в `any`. Это важно для 
* нашего первого теста.

После применения этого Terraform-кода (`terraform apply`) у нас будет готовый к работе кластер PostgreSQL.

### Выбор языка для тестирования: Go

Для написания тестового приложения, которое будет подключаться к нашему кластеру и выполнять операции записи, мы выбрали 
язык Go (Golang). Go является достаточно популярным языком для разработки бэкенд-сервисов, обладает отличной стандартной 
библиотекой, мощными инструментами для работы с конкурентностью и имеет зрелые драйверы для работы с PostgreSQL, 
такие как `pgx`.

Наше тестовое приложение (`main.go`) будет в бесконечном цикле пытаться вставить данные в таблицу, логируя результат 
каждой попытки, включая информацию о пуле соединений и узле, к которому было выполнено подключение.

```go
{{ cat "main.go" }}
```

Ключевые моменты в коде `main.go`:
1.  **Сборка строки подключения**: Функция `buildConnStringFromEnv` читает параметры из переменных окружения (которые 
2. мы получаем из `.env` файла, сгенерированного Terraform) и формирует строку подключения. Важно, что `target_session_attrs` также берется из окружения.
2.  **Получение информации о соединении**: Функция `GetConnectionInfo` перед каждой операцией (или в случае ошибки) запрашивает у пула соединений `pgxpool.Pool` информацию о текущем состоянии пула. Затем она берет одно соединение из пула, определяет его удаленный IP-адрес и запрашивает у PostgreSQL, является ли текущий узел репликой (`SELECT pg_is_in_recovery()`). Это позволяет нам точно знать, на какой узел (мастер или реплика) пошла операция.
3.  **Цикл вставок**: В `main` функции приложение создает таблицу `test`, если она не существует, а затем входит в бесконечный цикл, каждую секунду пытаясь вставить новую запись с текущим временем. Логируется либо успешная вставка, либо ошибка, всегда с указанием информации о соединении.

Для сборки и запуска приложения мы будем использовать простой `Makefile`:

```makefile
{{ cat "Makefile" }}
```

Команда `make run` сначала выполнит `go mod tidy`, затем соберет исполняемый файл `switch-checker` и запустит его.

### Тестирование переключения мастера БЕЗ `target_session_attrs` (или с `target_session_attrs=any`)

Итак, у нас развернут кластер PostgreSQL в Яндекс.Облаке, и Terraform сгенерировал `.env` файл, в котором 
`TARGET_SESSION_ATTRS` установлен в `any`. Это значение означает, что драйверу разрешено подключаться к любому 
доступному хосту кластера, независимо от его роли (мастер или реплика).

Запустим наше Go-приложение:
1.  Убедитесь, что вы находитесь в директории с файлами `main.go`, `main.tf` и `Makefile`.
2.  Если вы еще не развернули инфраструктуру, выполните `terraform init` и `terraform apply`.
3.  После успешного создания кластера и файла `.env`, выполните `make run`.

Приложение начнет выполнять INSERT-запросы. В нормальном состоянии все запросы будут идти на мастер-узел. Теперь давайте 
сымитируем сбой мастера или плановое переключение. В консоли управления Яндекс.Облака для вашего кластера Managed Service 
for PostgreSQL вы можете инициировать операцию переключения мастера (Start Failover).

После того как переключение мастера произойдет, мы начнем наблюдать в логах нашего приложения следующую картину:

```
2025/05/18 12:45:10 Connected!!
2025/05/18 12:45:10 postgres://test:SuperSecurePassw0rd@c-xxxxxxxxx.rw.mdb.yandexcloud.net:6432/testdb?pool_max_conns=2&pool_min_conns=2&pool_max_conn_lifetime=1h&pool_max_conn_idle_time=30m&default_query_exec_mode=simple_protocol&target_session_attrs=any
... (успешные вставки)
2025/05/18 12:46:16 Successful [Pool total: 2, acquired: 0, idle: 2 | IP: 62.84.123.60, Type: Master]: rows affected: 1
// Начинается переключение мастера, или приложение подключилось к реплике
2025/05/18 12:46:17 DB Error [Pool total: 2, acquired: 0, idle: 2 | IP: 89.169.156.108, Type: Replica] cannot execute INSERT in a read-only transaction (Code: 25006): ERROR: cannot execute INSERT in a read-only transaction (SQLSTATE 25006)
2025/05/18 12:46:17 DB Error [Pool total: 2, acquired: 0, idle: 2 | IP: 89.169.156.108, Type: Replica] cannot execute INSERT in a read-only transaction (Code: 25006): ERROR: cannot execute INSERT in a read-only transaction (SQLSTATE 25006)
// ... множество таких ошибок
2025/05/18 12:46:17 DB Error [Pool total: 2, acquired: 0, idle: 2 | IP: 89.169.156.108, Type: Replica] cannot execute INSERT in a read-only transaction (Code: 25006): ERROR: cannot execute INSERT in a read-only transaction (SQLSTATE 25006) - 54 раза (пример из запроса пользователя)
// Пул соединений мог обновить информацию и подключиться к новому мастеру, либо другой коннект из пула был к мастеру
2025/05/18 12:46:18 Successful [Pool total: 2, acquired: 0, idle: 2 | IP: 62.84.123.60, Type: Master]: rows affected: 1 - 54 раза (пример из запроса пользователя)
// Но через некоторое время ошибки могут повториться, если соединения к репликам остаются в пуле
2025/05/18 12:47:19 DB Error [Pool total: 2, acquired: 0, idle: 2 | IP: 89.169.156.108, Type: Replica] cannot execute INSERT in a read-only transaction (Code: 25006): ERROR: cannot execute INSERT in a read-only transaction (SQLSTATE 25006) - 54 раза (пример из запроса пользователя)
```

**Что мы видим в логах и почему это происходит?**

1.  **Определение типа хоста и IP**: Наш Go-код в функции `GetConnectionInfo` выполняет запрос `SELECT pg_is_in_recovery()`. Если он возвращает `true`, узел является репликой, иначе – мастером. Мы также получаем IP-адрес узла, к которому подключено данное соединение.
2.  **Подтверждение роли реплики**: Когда мы видим в логе `IP: 89.169.156.108, Type: Replica`, это означает, что наше приложение установило соединение с хостом `89.169.156.108`, и этот хост подтвердил, что он находится в режиме восстановления (т.е. является репликой).
3.  **Проблема с пулом соединений**: Библиотека `pgxpool` (и большинство других пулов соединений) поддерживает некоторое количество открытых соединений для повышения производительности. При `target_session_attrs=any`, пул может устанавливать соединения как с мастером, так и с репликами через общий FQDN кластера (например, `c-xxxxxxxxx.rw.mdb.yandexcloud.net`), который обычно указывает на текущий мастер, но при определенных обстоятельствах или при прямом подключении к FQDN реплик (если бы мы их использовали) может направить на реплику.
    Более того, даже если изначально все соединения в пуле были к мастеру, после переключения мастера эти "старые" соединения теперь ведут к узлу, который стал репликой. Приложение, беря такое соединение из пула для операции `INSERT`, сталкивается с ошибкой `cannot execute INSERT in a read-only transaction (Code: 25006)`.
4.  **Чередование ошибок и успехов**: Как видно из логов, предоставленных в примере, приложение может какое-то время получать ошибки, а затем успешно выполнить вставку. Это происходит потому, что в пуле (в нашем примере `POOL_MAX_CONNS=2`) может быть несколько соединений. Одно соединение может все еще указывать на старый мастер (теперь реплику), вызывая ошибку. Другое соединение могло быть установлено уже к новому мастеру (например, `IP: 62.84.123.60, Type: Master`), и операция через него пройдет успешно. Это создает нестабильное поведение и потерю данных (или необходимость сложной логики повторов в приложении).

Этот тест наглядно демонстрирует проблему: без явного указания на необходимость подключения к мастер-узлу для операций записи, приложение становится уязвимым к ошибкам во время переключения мастера или при неоптимальной конфигурации балансировки нагрузки на уровне кластера.

### Тестирование переключения мастера с `target_session_attrs=read-write`

Теперь давайте исправим эту ситуацию. Мы изменим параметр `TARGET_SESSION_ATTRS` в нашем файле `.env` на `read-write`. 
Это значение указывает драйверу `pgx`, что мы намерены подключаться к узлу, который способен обрабатывать как чтение, 
так и запись, то есть к мастеру.

1.  Остановите работающее Go-приложение (Ctrl+C).
2.  Откройте файл `.env` в вашем текстовом редакторе.
3.  Найдите строку `TARGET_SESSION_ATTRS=any` и измените ее на `TARGET_SESSION_ATTRS=read-write`.
    Содержимое `.env` теперь должно выглядеть примерно так (FQDN, пользователь, пароль и имя БД будут вашими):
    ```dotenv
    PG_HOST=c-xxxxxxxxx.rw.mdb.yandexcloud.net
    PG_PORT=6432
    PG_USER=test
    PG_PASSWORD=пароль
    PG_DB=testdb
    POOL_MAX_CONNS=2
    POOL_MIN_CONNS=2
    POOL_MAX_CONN_LIFETIME=1h
    POOL_MAX_CONN_IDLE_TIME=30m
    DEFAULT_QUERY_EXEC_MODE=simple_protocol
    TARGET_SESSION_ATTRS=read-write
    ```
4.  Сохраните изменения в файле `.env`.
5.  Снова запустите приложение: `make run`.

Теперь приложение будет подключаться к кластеру с инструкцией искать узел, поддерживающий чтение и запись. Драйвер `libpq` 
(который используется `pgx` под капотом при подключении к нескольким хостам или через специальный FQDN, как у Яндекс.Облака) 
будет использовать эту информацию для выбора подходящего хоста. Если текущее соединение ведет к реплике, драйвер попытается 
установить новое соединение с мастером.

Снова инициируйте переключение мастера в консоли Яндекс.Облака.

Наблюдайте за логами приложения. Вы заметите существенное отличие:

```
2025/05/18 13:10:15 Connected!!
2025/05/18 13:10:15 postgres://test:пароль@c-xxxxxxxxx.rw.mdb.yandexcloud.net:6432/testdb?pool_max_conns=2&pool_min_conns=2&pool_max_conn_lifetime=1h&pool_max_conn_idle_time=30m&default_query_exec_mode=simple_protocol&target_session_attrs=read-write
... (успешные вставки на текущий мастер)
2025/05/18 13:11:20 Successful [Pool total: 2, acquired: 0, idle: 2 | IP: 62.84.123.60, Type: Master]: rows affected: 1
// Происходит переключение мастера
// Может быть короткая пауза или несколько попыток переподключения, но ошибок "read-only transaction" быть не должно
// Драйвер и пул соединений отработают подключение к новому мастеру
2025/05/18 13:11:55 Successful [Pool total: 2, acquired: 0, idle: 2 | IP: 192.168.10.25, Type: Master]: rows affected: 1 // IP изменился на IP нового мастера
2025/05/18 13:11:56 Successful [Pool total: 2, acquired: 0, idle: 2 | IP: 192.168.10.25, Type: Master]: rows affected: 1
... (дальнейшие успешные вставки)
```

В логах вы больше не должны видеть ошибок `cannot execute INSERT in a read-only transaction`. Приложение может испытать 
короткую задержку во время фактического переключения мастера, пока драйвер устанавливает соединение с новым мастером, но 
операции записи не будут направляться на реплики. Пул соединений, работая совместно с драйвером, который учитывает 
`target_session_attrs=read-write`, будет гарантировать, что для операций используются только соединения с мастером. 
Любые соединения, которые после переключения мастера оказываются подключенными к реплике, не будут использоваться для 
операций записи или будут переустановлены.

### Вывод

Как мы продемонстрировали, использование параметра строки подключения `target_session_attrs` со значением `read-write` 
является критически важным для обеспечения стабильной работы приложений с кластерами PostgreSQL в конфигурациях с 
высокой доступностью.

**Ключевые преимущества использования `target_session_attrs=read-write`:**

1.  **Устойчивость к переключению мастера**: Приложение автоматически будет направлять запросы на запись на актуальный 
2. мастер-узел, минимизируя или полностью устраняя ошибки "read-only transaction" во время и после переключения.
2.  **Упрощение логики приложения**: Нет необходимости реализовывать сложную логику повторных попыток или обнаружения 
3. мастера на стороне приложения, так как эту задачу берет на себя драйвер СУБД.
3.  **Корректная работа с пулом соединений**: Пул соединений будет корректно обрабатывать соединения, гарантируя, что 
4. для операций записи используются только подходящие (master) коннекты.

Другие возможные значения для `target_session_attrs` включают:
*   `any` (по умолчанию, если не указано): подключаться к любому хосту. Как мы видели, это приводит к проблемам.
*   `read-only`: подключаться к хосту, который предпочтительно является репликой. Полезно для распределения нагрузки чтения.
*   `primary`: подключаться к основному серверу (синоним `read-write` во многих контекстах).
*   `standby`: подключаться к резервному серверу (синоним `read-only`).
*   `prefer-standby`: подключаться к резервному серверу, если доступен, иначе к основному.

Для большинства приложений, выполняющих как чтение, так и запись, `target_session_attrs=read-write` является наиболее 
подходящим и надежным выбором.

Поэтому, если вы работаете с кластером PostgreSQL и хотите избежать головной боли, связанной с ошибками записи на реплики, 
**всегда используйте `target_session_attrs=read-write`** в строке подключения вашего приложения. Это небольшое изменение 
может значительно повысить надежность и отказоустойчивость вашей системы.