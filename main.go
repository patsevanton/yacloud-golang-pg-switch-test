package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"strings"
	"time"

	"github.com/joho/godotenv"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/jackc/pgx/v5/stdlib"
	"github.com/jmoiron/sqlx"
)

func main() {
	if err := godotenv.Load(); err != nil {
		log.Println("Warning: no .env file found, trying to read env from system")
	}

	ctx := context.TODO()
	connString1 := buildConnStringFromEnv()
	log.Println(connString1)

	connString := "postgres://test:xxxx@c-xxxx.rw.mdb.yandexcloud.net:6432/testdb?" +
		"pool_max_conns=2&pool_min_conns=2&pool_max_conn_lifetime=1h" +
		"&pool_max_conn_idle_time=30m&default_query_exec_mode=simple_protocol&target_session_attrs=read-write"

	log.Println(connString)
	db, pool, err := GetDB(ctx, connString)
	if err != nil {
		log.Fatal(err)
	}

	log.Println("Connected!!")

	if _, err := db.Exec(`create table if not exists test (
	   id bigint GENERATED BY DEFAULT AS IDENTITY primary key,
	   created_at timestamptz not null
	 )`); err != nil {
		log.Fatalf("unable to create table: %v\n", err)
	}

	for {
		result, err := db.Exec(
			`insert into "test" ("created_at") values ($1)`, time.Now())

		if err != nil {
			connInfo := GetConnectionInfo(ctx, pool)
			pgErr, ok := err.(*pgconn.PgError)
			if ok {
				log.Printf("DB Error [%s] %s (Code: %s): %s", connInfo, pgErr.Message, pgErr.Code, err)
			} else {
				log.Printf("DB Error [%s]: %s", connInfo, err)
			}
			time.Sleep(1 * time.Second)
			continue
		}

		connInfo := GetConnectionInfo(ctx, pool)
		rowsAffected, _ := result.RowsAffected()
		log.Printf("Successful [%s]: rows affected: %d", connInfo, rowsAffected)
		time.Sleep(1 * time.Second)
	}
}

func buildConnStringFromEnv() string {
	user := os.Getenv("PG_USER")
	password := os.Getenv("PG_PASSWORD")
	host := os.Getenv("PG_HOST")
	port := os.Getenv("PG_PORT")
	db := os.Getenv("PG_DB")

	poolMaxConns := os.Getenv("POOL_MAX_CONNS")
	poolMinConns := os.Getenv("POOL_MIN_CONNS")
	poolMaxConnLifetime := os.Getenv("POOL_MAX_CONN_LIFETIME")
	poolMaxConnIdleTime := os.Getenv("POOL_MAX_CONN_IDLE_TIME")
	defaultQueryExecMode := os.Getenv("DEFAULT_QUERY_EXEC_MODE")
	targetSessionAttrs := os.Getenv("TARGET_SESSION_ATTRS")

	connString := fmt.Sprintf(
		"postgres://%s:%s@%s:%s/%s?pool_max_conns=%s&pool_min_conns=%s&pool_max_conn_lifetime=%s" +
		"&pool_max_conn_idle_time=%s&default_query_exec_mode=%s&target_session_attrs=%s",
		user, password, host, port, db, poolMaxConns, poolMinConns, poolMaxConnLifetime,
		poolMaxConnIdleTime, defaultQueryExecMode, targetSessionAttrs,
	)

	return connString
}

func GetConnectionInfo(ctx context.Context, pool *pgxpool.Pool) string {
	var connInfo strings.Builder
	stat := pool.Stat()
	connInfo.WriteString(fmt.Sprintf("Pool total: %d, acquired: %d, idle: %d | ",
		stat.TotalConns(), stat.AcquiredConns(), stat.IdleConns()))

	conn, err := pool.Acquire(ctx)
	if err != nil {
		return connInfo.String() + "Failed to acquire connection"
	}
	defer conn.Release()

	remoteAddr := conn.Conn().PgConn().Conn().RemoteAddr().String()
	host, _, _ := net.SplitHostPort(remoteAddr)

	var readOnly bool
	err = conn.QueryRow(ctx, "SELECT pg_is_in_recovery()").Scan(&readOnly)
	if err != nil {
		connInfo.WriteString(fmt.Sprintf("IP: %s, Error getting read-only status", host))
		return connInfo.String()
	}

	serverType := "Master"
	if readOnly {
		serverType = "Replica"
	}

	connInfo.WriteString(fmt.Sprintf("IP: %s, Type: %s", host, serverType))
	return connInfo.String()
}

func GetDB(ctx context.Context, uri string) (*sqlx.DB, *pgxpool.Pool, error) {
	DB, pool, err := PgxCreateDB(ctx, uri)
	if err != nil {
		return nil, nil, err
	}
	return DB, pool, nil
}

func PgxCreateDB(ctx context.Context, uri string) (*sqlx.DB, *pgxpool.Pool, error) {
	connConfig, err := pgxpool.ParseConfig(uri)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to parse connection config: %w", err)
	}

	pool, err := pgxpool.NewWithConfig(ctx, connConfig)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create connection pool: %w", err)
	}

	if err := pool.Ping(ctx); err != nil {
		return nil, nil, fmt.Errorf("failed to ping DB: %w", err)
	}

	pgxdb := stdlib.OpenDBFromPool(pool)
	return sqlx.NewDb(pgxdb, "pgx"), pool, nil
}